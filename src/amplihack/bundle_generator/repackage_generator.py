"""Generate repackaging scripts for agent bundles."""

import stat
from pathlib import Path

from .models import AgentBundle


def generate_bash_script(bundle: AgentBundle) -> str:
    """
    Generate bash repackage script with validation, testing, and building.

    Args:
        bundle: AgentBundle to generate script for

    Returns:
        Complete bash script content
    """
    # Sanitize bundle name to prevent script injection
    safe_name = sanitize_bundle_name(bundle.name)
    safe_version = sanitize_version(bundle.version)

    return f"""#!/usr/bin/env bash
# Repackage script for {safe_name}
# Generated by Agent Bundle Generator

set -euo pipefail

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m' # No Color

# Configuration
BUNDLE_NAME="{safe_name}"
BUNDLE_VERSION="{safe_version}"
PACKAGE_NAME="${{BUNDLE_NAME}}-${{BUNDLE_VERSION}}"
OUTPUT_DIR="./dist"

# Functions
log_info() {{
    echo -e "${{GREEN}}[INFO]${{NC}} $1"
}}

log_warn() {{
    echo -e "${{YELLOW}}[WARN]${{NC}} $1"
}}

log_error() {{
    echo -e "${{RED}}[ERROR]${{NC}} $1"
}}

check_prerequisites() {{
    log_info "Checking prerequisites..."

    # Check Python version
    if ! command -v python3 &> /dev/null; then
        log_error "Python 3 not found"
        exit 1
    fi

    PYTHON_VERSION=$(python3 --version | cut -d' ' -f2)
    log_info "Python version: $PYTHON_VERSION"

    # Check if pytest is available
    if command -v pytest &> /dev/null; then
        log_info "pytest: $(pytest --version | head -1)"
    else
        log_warn "pytest not found - skipping tests"
    fi

    # Check if uvx is available
    if command -v uvx &> /dev/null; then
        log_info "uvx: available"
    else
        log_warn "uvx not found - will skip UVX packaging"
    fi
}}

validate_structure() {{
    log_info "Validating bundle structure..."

    # Check required directories
    REQUIRED_DIRS=("agents" "tests" "config")
    for dir in "${{REQUIRED_DIRS[@]}}"; do
        if [ ! -d "$dir" ]; then
            log_error "Missing required directory: $dir"
            exit 1
        fi
    done

    # Check required files
    REQUIRED_FILES=("manifest.json" "README.md" "setup.py")
    for file in "${{REQUIRED_FILES[@]}}"; do
        if [ ! -f "$file" ]; then
            log_error "Missing required file: $file"
            exit 1
        fi
    done

    # Check manifest.json is valid JSON
    if ! python3 -c "import json; json.load(open('manifest.json'))" 2>/dev/null; then
        log_error "Invalid manifest.json"
        exit 1
    fi

    # Count agents
    AGENT_COUNT=$(ls -1 agents/*.md 2>/dev/null | wc -l | tr -d ' ')
    log_info "Found $AGENT_COUNT agent(s)"

    if [ "$AGENT_COUNT" -eq 0 ]; then
        log_error "No agents found in agents/ directory"
        exit 1
    fi

    log_info "Structure validation: PASSED"
}}

run_tests() {{
    log_info "Running tests..."

    if ! command -v pytest &> /dev/null; then
        log_warn "pytest not available - skipping tests"
        return 0
    fi

    if [ ! -d "tests" ] || [ -z "$(ls -A tests/*.py 2>/dev/null)" ]; then
        log_warn "No tests found - skipping"
        return 0
    fi

    # Run pytest with coverage if available
    if pytest tests/ -v --tb=short; then
        log_info "Tests: PASSED"
    else
        log_error "Tests: FAILED"
        echo ""
        echo "Fix test failures before repackaging"
        exit 1
    fi
}}

build_package() {{
    log_info "Building package..."

    # Create output directory
    mkdir -p "$OUTPUT_DIR"

    # Build source distribution
    log_info "Building source distribution..."
    if python3 setup.py sdist --dist-dir="$OUTPUT_DIR" > /dev/null 2>&1; then
        log_info "Source distribution: CREATED"
    else
        log_warn "Source distribution failed"
    fi

    # Build wheel if possible
    if command -v pip &> /dev/null && pip show wheel &> /dev/null; then
        log_info "Building wheel..."
        if python3 setup.py bdist_wheel --dist-dir="$OUTPUT_DIR" > /dev/null 2>&1; then
            log_info "Wheel: CREATED"
        else
            log_warn "Wheel build failed"
        fi
    fi

    # Build UVX package if uvx is available
    if command -v uvx &> /dev/null; then
        log_info "Building UVX package..."

        # Create temporary package directory
        TEMP_DIR=$(mktemp -d)
        PACKAGE_DIR="$TEMP_DIR/$PACKAGE_NAME"

        # Copy all files
        mkdir -p "$PACKAGE_DIR"
        cp -r agents tests docs config *.py *.json *.md "$PACKAGE_DIR/" 2>/dev/null || true

        # Create tarball with .uvx extension
        cd "$TEMP_DIR"
        tar -czf "$PACKAGE_NAME.uvx" "$PACKAGE_NAME"
        mv "$PACKAGE_NAME.uvx" "$(pwd | sed 's|/[^/]*$||')/$OUTPUT_DIR/"
        cd - > /dev/null

        # Cleanup
        rm -rf "$TEMP_DIR"

        log_info "UVX package: CREATED"
    fi
}}

calculate_checksums() {{
    log_info "Calculating checksums..."

    if [ -d "$OUTPUT_DIR" ]; then
        cd "$OUTPUT_DIR"

        # Create checksums file
        if command -v sha256sum &> /dev/null; then
            sha256sum * > SHA256SUMS 2>/dev/null || true
            log_info "Checksums: SHA256SUMS created"
        elif command -v shasum &> /dev/null; then
            shasum -a 256 * > SHA256SUMS 2>/dev/null || true
            log_info "Checksums: SHA256SUMS created"
        fi

        cd - > /dev/null
    fi
}}

print_summary() {{
    echo ""
    echo "========================================"
    echo "Repackaging Complete!"
    echo "========================================"
    echo "Bundle: $BUNDLE_NAME"
    echo "Version: $BUNDLE_VERSION"
    echo ""

    if [ -d "$OUTPUT_DIR" ]; then
        echo "Output files:"
        ls -lh "$OUTPUT_DIR" | tail -n +2 | awk '{{printf "  %s (%s)\\n", $9, $5}}'
    fi

    echo ""
    echo "Next steps:"
    echo "  1. Test the package: uvx install $OUTPUT_DIR/$PACKAGE_NAME.uvx"
    echo "  2. Distribute: Copy files from $OUTPUT_DIR/"
    echo "========================================"
}}

# Main execution
main() {{
    echo "========================================"
    echo "Repackaging $BUNDLE_NAME v$BUNDLE_VERSION"
    echo "========================================"
    echo ""

    check_prerequisites
    echo ""

    validate_structure
    echo ""

    run_tests
    echo ""

    build_package
    echo ""

    calculate_checksums
    echo ""

    print_summary
}}

# Run main function
main "$@"
"""


def generate_python_script(bundle: AgentBundle) -> str:
    """
    Generate Python repackage script with same functionality as bash.

    Args:
        bundle: AgentBundle to generate script for

    Returns:
        Complete Python script content
    """
    # Sanitize bundle name and version
    safe_name = sanitize_bundle_name(bundle.name)
    safe_version = sanitize_version(bundle.version)

    return f"""#!/usr/bin/env python3
\"\"\"
Repackage script for {safe_name}
Generated by Agent Bundle Generator
\"\"\"

import hashlib
import json
import shutil
import subprocess
import sys
import tarfile
import tempfile
from pathlib import Path
from typing import Optional


class Colors:
    \"\"\"ANSI color codes for terminal output.\"\"\"
    RED = '\\033[0;31m'
    GREEN = '\\033[0;32m'
    YELLOW = '\\033[1;33m'
    NC = '\\033[0m'  # No Color


class Repackager:
    \"\"\"Repackage agent bundle with validation and testing.\"\"\"

    def __init__(self):
        self.bundle_name = "{safe_name}"
        self.bundle_version = "{safe_version}"
        self.package_name = f"{{self.bundle_name}}-{{self.bundle_version}}"
        self.output_dir = Path("./dist")
        self.errors = []
        self.warnings = []

    def log_info(self, message: str):
        \"\"\"Log info message.\"\"\"
        print(f"{{Colors.GREEN}}[INFO]{{Colors.NC}} {{message}}")  # noqa: T201 (print)

    def log_warn(self, message: str):
        \"\"\"Log warning message.\"\"\"
        print(f"{{Colors.YELLOW}}[WARN]{{Colors.NC}} {{message}}")  # noqa: T201 (print)
        self.warnings.append(message)

    def log_error(self, message: str):
        \"\"\"Log error message.\"\"\"
        print(f"{{Colors.RED}}[ERROR]{{Colors.NC}} {{message}}")  # noqa: T201 (print)
        self.errors.append(message)

    def check_command(self, command: str) -> bool:
        \"\"\"Check if command is available.\"\"\"
        return shutil.which(command) is not None

    def run_command(self, cmd: list, capture: bool = False) -> Optional[str]:
        \"\"\"Run shell command.\"\"\"
        try:
            if capture:
                result = subprocess.run(
                    cmd, capture_output=True, text=True, check=True
                )
                return result.stdout.strip()
            else:
                subprocess.run(cmd, check=True)
                return None
        except subprocess.CalledProcessError as e:
            self.log_error(f"Command failed: {{' '.join(cmd)}}")
            if capture and e.stderr:
                self.log_error(e.stderr)
            return None

    def check_prerequisites(self) -> bool:
        \"\"\"Check required tools and versions.\"\"\"
        self.log_info("Checking prerequisites...")

        # Check Python version
        python_version = sys.version.split()[0]
        self.log_info(f"Python version: {{python_version}}")

        major, minor = map(int, python_version.split('.')[:2])
        if major < 3 or (major == 3 and minor < 11):
            self.log_error("Python 3.11 or higher required")
            return False

        # Check pytest
        if self.check_command("pytest"):
            version = self.run_command(["pytest", "--version"], capture=True)
            self.log_info(f"pytest: {{version}}")
        else:
            self.log_warn("pytest not found - skipping tests")

        # Check uvx
        if self.check_command("uvx"):
            self.log_info("uvx: available")
        else:
            self.log_warn("uvx not found - will skip UVX packaging")

        return True

    def validate_structure(self) -> bool:
        \"\"\"Validate bundle structure.\"\"\"
        self.log_info("Validating bundle structure...")

        # Check required directories
        required_dirs = ["agents", "tests", "config"]
        for dir_name in required_dirs:
            dir_path = Path(dir_name)
            if not dir_path.exists() or not dir_path.is_dir():
                self.log_error(f"Missing required directory: {{dir_name}}")
                return False

        # Check required files
        required_files = ["manifest.json", "README.md", "setup.py"]
        for file_name in required_files:
            file_path = Path(file_name)
            if not file_path.exists():
                self.log_error(f"Missing required file: {{file_name}}")
                return False

        # Validate manifest.json
        try:
            with open("manifest.json") as f:
                manifest = json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            self.log_error(f"Invalid manifest.json: {{e}}")
            return False

        # Count agents
        agents_dir = Path("agents")
        agent_files = list(agents_dir.glob("*.md"))
        agent_count = len(agent_files)
        self.log_info(f"Found {{agent_count}} agent(s)")

        if agent_count == 0:
            self.log_error("No agents found in agents/ directory")
            return False

        self.log_info("Structure validation: PASSED")
        return True

    def run_tests(self) -> bool:
        \"\"\"Run test suite.\"\"\"
        self.log_info("Running tests...")

        if not self.check_command("pytest"):
            self.log_warn("pytest not available - skipping tests")
            return True

        tests_dir = Path("tests")
        test_files = list(tests_dir.glob("test_*.py"))

        if not test_files:
            self.log_warn("No tests found - skipping")
            return True

        # Run pytest
        result = subprocess.run(
            ["pytest", "tests/", "-v", "--tb=short"],
            capture_output=False
        )

        if result.returncode == 0:
            self.log_info("Tests: PASSED")
            return True
        else:
            self.log_error("Tests: FAILED")
            print("\\nFix test failures before repackaging")  # noqa: T201 (print)
            return False

    def build_package(self) -> bool:
        \"\"\"Build distribution packages.\"\"\"
        self.log_info("Building package...")

        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Build source distribution
        self.log_info("Building source distribution...")
        if self.run_command(
            [sys.executable, "setup.py", "sdist", f"--dist-dir={{self.output_dir}}"]
        ) is not None:
            self.log_info("Source distribution: CREATED")
        else:
            self.log_warn("Source distribution failed")

        # Build wheel if possible
        try:
            import wheel  # noqa
            self.log_info("Building wheel...")
            if self.run_command(
                [sys.executable, "setup.py", "bdist_wheel", f"--dist-dir={{self.output_dir}}"]
            ) is not None:
                self.log_info("Wheel: CREATED")
            else:
                self.log_warn("Wheel build failed")
        except ImportError:
            self.log_warn("wheel package not installed - skipping")

        # Build UVX package
        if self.check_command("uvx"):
            self.log_info("Building UVX package...")
            try:
                self._build_uvx_package()
                self.log_info("UVX package: CREATED")
            except Exception as e:
                self.log_warn(f"UVX package failed: {{e}}")

        return True

    def _build_uvx_package(self):
        \"\"\"Build UVX package format.\"\"\"
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            package_dir = temp_path / self.package_name

            # Copy all files
            package_dir.mkdir(parents=True)

            # Copy directories
            for dir_name in ["agents", "tests", "docs", "config"]:
                src = Path(dir_name)
                if src.exists():
                    shutil.copytree(src, package_dir / dir_name)

            # Copy files
            for pattern in ["*.py", "*.json", "*.md"]:
                for file_path in Path(".").glob(pattern):
                    if file_path.is_file():
                        shutil.copy2(file_path, package_dir / file_path.name)

            # Create tarball with .uvx extension
            uvx_path = self.output_dir / f"{{self.package_name}}.uvx"
            with tarfile.open(uvx_path, "w:gz") as tar:
                tar.add(package_dir, arcname=self.package_name)

    def calculate_checksums(self):
        \"\"\"Calculate SHA256 checksums for all packages.\"\"\"
        self.log_info("Calculating checksums...")

        if not self.output_dir.exists():
            return

        checksums = []
        for file_path in self.output_dir.glob("*"):
            if file_path.is_file() and file_path.name != "SHA256SUMS":
                sha256 = hashlib.sha256()
                with open(file_path, "rb") as f:
                    for chunk in iter(lambda: f.read(4096), b""):
                        sha256.update(chunk)
                checksums.append(f"{{sha256.hexdigest()}}  {{file_path.name}}")

        if checksums:
            checksums_file = self.output_dir / "SHA256SUMS"
            checksums_file.write_text("\\n".join(checksums) + "\\n")
            self.log_info("Checksums: SHA256SUMS created")

    def print_summary(self):
        \"\"\"Print repackaging summary.\"\"\"
        print("\\n" + "=" * 40)  # noqa: T201 (print)
        print("Repackaging Complete!")  # noqa: T201 (print)
        print("=" * 40)  # noqa: T201 (print)
        print(f"Bundle: {{self.bundle_name}}")  # noqa: T201 (print)
        print(f"Version: {{self.bundle_version}}")  # noqa: T201 (print)
        print()  # noqa: T201 (print)

        if self.output_dir.exists():
            print("Output files:")  # noqa: T201 (print)
            for file_path in sorted(self.output_dir.glob("*")):
                if file_path.is_file():
                    size = file_path.stat().st_size
                    if size < 1024:
                        size_str = f"{{size}}B"
                    elif size < 1024 * 1024:
                        size_str = f"{{size / 1024:.1f}}KB"
                    else:
                        size_str = f"{{size / (1024 * 1024):.1f}}MB"
                    print(f"  {{file_path.name}} ({{size_str}})")  # noqa: T201 (print)

        print()  # noqa: T201 (print)
        print("Next steps:")  # noqa: T201 (print)
        print(f"  1. Test the package: uvx install {{self.output_dir}}/{{self.package_name}}.uvx")  # noqa: T201 (print)
        print(f"  2. Distribute: Copy files from {{self.output_dir}}/")  # noqa: T201 (print)
        print("=" * 40)  # noqa: T201 (print)

        if self.warnings:
            print(f"\\nWarnings: {{len(self.warnings)}}")  # noqa: T201 (print)
            for warning in self.warnings:
                print(f"  - {{warning}}")  # noqa: T201 (print)

    def run(self) -> int:
        \"\"\"Run complete repackaging process.\"\"\"
        print("=" * 40)  # noqa: T201 (print)
        print(f"Repackaging {{self.bundle_name}} v{{self.bundle_version}}")  # noqa: T201 (print)
        print("=" * 40)  # noqa: T201 (print)
        print()  # noqa: T201 (print)

        if not self.check_prerequisites():
            return 1
        print()  # noqa: T201 (print)

        if not self.validate_structure():
            return 1
        print()  # noqa: T201 (print)

        if not self.run_tests():
            return 1
        print()  # noqa: T201 (print)

        if not self.build_package():
            return 1
        print()  # noqa: T201 (print)

        self.calculate_checksums()
        print()  # noqa: T201 (print)

        self.print_summary()

        return 0 if not self.errors else 1


def main():
    \"\"\"Main entry point.\"\"\"
    repackager = Repackager()
    sys.exit(repackager.run())


if __name__ == "__main__":
    main()
"""


def make_executable(script_path: Path) -> None:
    """
    Make script executable by adding executable permission.

    Args:
        script_path: Path to script file

    Raises:
        OSError: If chmod operation fails
    """
    if not script_path.exists():
        raise FileNotFoundError(f"Script not found: {script_path}")

    # Add executable permission for owner, group, and others
    current_permissions = script_path.stat().st_mode
    new_permissions = current_permissions | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH
    script_path.chmod(new_permissions)


def sanitize_bundle_name(name: str) -> str:
    """
    Sanitize bundle name to prevent script injection.

    Args:
        name: Raw bundle name

    Returns:
        Sanitized name safe for use in scripts
    """
    # Only allow alphanumeric, hyphens, and underscores
    sanitized = "".join(c for c in name if c.isalnum() or c in "-_")
    if not sanitized:
        raise ValueError(f"Bundle name contains no valid characters: {name}")
    return sanitized


def sanitize_version(version: str) -> str:
    """
    Sanitize version string to prevent script injection.

    Args:
        version: Raw version string

    Returns:
        Sanitized version safe for use in scripts
    """
    # Only allow numbers, dots, and common version separators
    sanitized = "".join(c for c in version if c.isdigit() or c in ".-")
    if not sanitized:
        raise ValueError(f"Version contains no valid characters: {version}")
    return sanitized
