"""
Authentication Service - core authentication logic for login and registration.
Orchestrates password verification, token generation, and user management.
"""

from typing import Optional
from datetime import datetime, timezone

from ..models import User, RegisterRequest, LoginRequest, LoginResponse, UserResponse
from ..exceptions import (
    InvalidCredentialsError,
    AccountLockedError,
    AccountNotActiveError,
    UserAlreadyExistsError,
    TooManyFailedAttemptsError,
    RateLimitExceededError,
)
from ..config import AuthConfig
from .password_service import PasswordService
from .token_service import TokenService
from ..repository.user_repository import UserRepository
from .rate_limiter import RateLimiter
from .audit_logger import AuditLogger


class AuthenticationService:
    """Service for user authentication operations."""

    def __init__(
        self,
        user_repository: UserRepository,
        password_service: PasswordService,
        token_service: TokenService,
        rate_limiter: RateLimiter,
        audit_logger: AuditLogger,
        config: Optional[AuthConfig] = None
    ):
        """
        Initialize authentication service.

        Args:
            user_repository: User repository
            password_service: Password service
            token_service: Token service
            rate_limiter: Rate limiter
            audit_logger: Audit logger
            config: Authentication configuration
        """
        self.user_repository = user_repository
        self.password_service = password_service
        self.token_service = token_service
        self.rate_limiter = rate_limiter
        self.audit_logger = audit_logger
        self.config = config or AuthConfig()

    def register(
        self,
        request: RegisterRequest,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> User:
        """
        Register a new user.

        Args:
            request: Registration request
            ip_address: Request IP address
            user_agent: Request user agent

        Returns:
            Created user

        Raises:
            UserAlreadyExistsError: If email or username already exists
            RateLimitExceededError: If rate limit exceeded
        """
        # Check rate limit
        is_allowed, retry_after = self.rate_limiter.check_rate_limit(
            request.email, "register"
        )
        if not is_allowed:
            raise RateLimitExceededError(retry_after)

        # Check if email already exists
        existing_user = self.user_repository.find_by_email(request.email)
        if existing_user:
            raise UserAlreadyExistsError("Email already registered")

        # Check if username already exists
        existing_user = self.user_repository.find_by_username(request.username)
        if existing_user:
            raise UserAlreadyExistsError("Username already taken")

        # Hash password
        password_hash = self.password_service.hash_password(request.password)

        # Create user
        user = User(
            id="",  # Will be generated by repository
            email=request.email.lower(),
            username=request.username,
            password_hash=password_hash,
            first_name=request.first_name,
            last_name=request.last_name,
            is_active=True,
            is_verified=not self.config.require_email_verification,
            is_locked=False,
            roles=["user"],
            permissions=[],
            created_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc),
        )

        # Save user
        saved_user = self.user_repository.save(user)

        # Log registration
        self.audit_logger.log_user_registration(
            user_id=saved_user.id,
            email=saved_user.email,
            username=saved_user.username,
            ip_address=ip_address,
            user_agent=user_agent
        )

        return saved_user

    def login(
        self,
        request: LoginRequest,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> LoginResponse:
        """
        Authenticate user and generate tokens.

        Args:
            request: Login request
            ip_address: Request IP address
            user_agent: Request user agent

        Returns:
            Login response with tokens

        Raises:
            InvalidCredentialsError: If credentials are invalid
            AccountLockedError: If account is locked
            AccountNotActiveError: If account is not active
            RateLimitExceededError: If rate limit exceeded
            TooManyFailedAttemptsError: If too many failed attempts
        """
        # Determine identifier for rate limiting
        identifier = request.email or request.username or ""

        # Check rate limit
        is_allowed, retry_after = self.rate_limiter.check_rate_limit(
            identifier, "login"
        )
        if not is_allowed:
            raise RateLimitExceededError(retry_after)

        # Find user
        user = None
        if request.email:
            user = self.user_repository.find_by_email(request.email.lower())
        elif request.username:
            user = self.user_repository.find_by_username(request.username)

        if not user:
            # Log failed login
            self.audit_logger.log_failed_login(
                email=identifier,
                reason="user_not_found",
                ip_address=ip_address,
                user_agent=user_agent
            )
            raise InvalidCredentialsError()

        # Check if account is locked
        if self.user_repository.is_account_locked(user.id):
            raise AccountLockedError()

        # Check if account is active
        if not user.is_active:
            raise AccountNotActiveError()

        # Verify password
        is_valid = self.password_service.verify_password(
            request.password,
            user.password_hash
        )

        if not is_valid:
            # Increment failed attempts
            self.user_repository.increment_failed_attempts(user.id)

            # Check if should lock account
            if user.failed_login_attempts + 1 >= self.config.max_login_attempts:
                self.user_repository.lock_account(
                    user.id,
                    self.config.lockout_duration_minutes
                )
                self.audit_logger.log_account_locked(
                    user_id=user.id,
                    email=user.email,
                    reason="too_many_failed_attempts",
                    ip_address=ip_address
                )
                raise TooManyFailedAttemptsError()

            # Log failed login
            self.audit_logger.log_failed_login(
                email=user.email,
                reason="invalid_password",
                ip_address=ip_address,
                user_agent=user_agent
            )
            raise InvalidCredentialsError()

        # Password is valid - reset failed attempts
        self.user_repository.reset_failed_attempts(user.id)

        # Update last login
        self.user_repository.update_last_login(user.id)

        # Generate tokens
        access_token = self.token_service.generate_access_token(
            user_id=user.id,
            email=user.email,
            username=user.username,
            roles=user.roles,
            permissions=user.permissions
        )

        refresh_token = self.token_service.generate_refresh_token(user.id)

        # Calculate expiration
        expires_in = self.token_service.config.access_token_expire_minutes * 60
        if request.remember_me:
            expires_in = self.token_service.config.refresh_token_expire_days * 24 * 60 * 60

        # Log successful login
        self.audit_logger.log_successful_login(
            user_id=user.id,
            email=user.email,
            ip_address=ip_address,
            user_agent=user_agent
        )

        # Create response
        user_response = UserResponse(
            id=user.id,
            email=user.email,
            username=user.username,
            first_name=user.first_name,
            last_name=user.last_name,
            is_active=user.is_active,
            is_verified=user.is_verified,
            roles=user.roles,
            created_at=user.created_at
        )

        return LoginResponse(
            access_token=access_token,
            refresh_token=refresh_token,
            token_type="Bearer",
            expires_in=expires_in,
            user=user_response
        )

    def refresh_token(
        self,
        refresh_token: str,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> dict:
        """
        Refresh access token using refresh token.

        Args:
            refresh_token: Refresh token
            ip_address: Request IP address
            user_agent: Request user agent

        Returns:
            New access token and expiration

        Raises:
            TokenExpiredError: If token expired
            TokenInvalidError: If token invalid
            AccountNotActiveError: If account not active
        """
        # Validate refresh token
        payload = self.token_service.validate_token(
            refresh_token,
            token_type="refresh"
        )

        # Get user
        user = self.user_repository.find_by_id(payload.user_id)
        if not user:
            raise InvalidCredentialsError("User not found")

        # Check if account is active
        if not user.is_active:
            raise AccountNotActiveError()

        # Generate new access token
        access_token = self.token_service.generate_access_token(
            user_id=user.id,
            email=user.email,
            username=user.username,
            roles=user.roles,
            permissions=user.permissions
        )

        expires_in = self.token_service.config.access_token_expire_minutes * 60

        # Log token refresh
        self.audit_logger.log_token_refreshed(
            user_id=user.id,
            email=user.email,
            ip_address=ip_address,
            user_agent=user_agent
        )

        return {
            "access_token": access_token,
            "token_type": "Bearer",
            "expires_in": expires_in
        }

    def logout(
        self,
        access_token: str,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ):
        """
        Logout user by revoking token.

        Args:
            access_token: Access token to revoke
            ip_address: Request IP address
            user_agent: Request user agent
        """
        # Validate and get user from token
        payload = self.token_service.validate_token(access_token, check_blacklist=False)

        # Revoke token
        self.token_service.revoke_token(access_token)

        # Log logout
        self.audit_logger.log_logout(
            user_id=payload.user_id,
            email=payload.email,
            ip_address=ip_address,
            user_agent=user_agent
        )
